# CPU Scheduler Simulation
---

#### 17 Nov 2023
#### 5143 CPU Scheduler Project 

#### Group Members
 
- Marcos Lopez
- Patrick Mitchell
- Jon Scales

### Overview:
#### States
This is a project written in python that simulates a CPU scheduler which moves simulated computational processes (PCBs) through a series of 5 states: New -> Ready -> CPU -> Wait -> IO -> Terminated.  Processes in IO will return to the Ready state to await further CPU processing upon completion of their IO burst. Each system state is simulated by a list container. Each PCB ends with a CPU run and exits to the Terminated state.  Each PCB is simulated with an ID, a system arrival time, a priority, a set of CPU bursts and a set of IO bursts. All PCBs within a .dat file are read into a dictionary. CPU & IO bursts simulate processor time within the CPU state or access to peripheral devices within the IO state respectively. The simulation runs as a loop with each cycle of the loop acting as a "clock tick" of the system clock. PCBs will be added to the new state in accordance with their associated system arrival time.  

#### Processes (PCBs)
Multiple batches of simulated processes were run through the simulation.  These batches take the form of .dat files generated by the generate.py program.  We utilized 9 different process batches as follows: 

 - SEven - 20 PCBs with 15-20 CPU & IO bursts of approximately equal lengths ranging from 10-18 clock ticks/burst
 - SCPUInt = 20 PCBs with 15-20 CPU & IO bursts with the CPU bursts 4-7 times longer than the IO burst lengths 
 - SIOInt = 20 PCBs with 15-20 CPU & IO bursts with the IO bursts ~2 times longer than the CPU burst lengths 
 - MEven & LEven - as above for SEven but with 50 or 100 PCBs respectivily
 - MCPUInt & MCPUInt - as above for SCPUInt but with 50 or 100 PCBs respectivily
 - MIOInt & LIOInt - as above for SIOInt but with 50 or 100 PCBs respectivily

#### Scheduler Algorithms & Implementation Steps
Three scheduler algorithms were implemented:  first-come-first-served (FCFS), priority-based-FCFS (PB), and round-robin (RR) using a time slice. Each type of algorithm was implemented with the ability to vary the number of CPU and IO states, vary the alloted cpu timeslice as well as augment priorities to prevent starvation of PCBs with lower priorities. 

During each clock tick the following events occur:
1. The time of PCBs in the wait or ready states is incremented +1
2. Any PCB in the new state is moved to ready
3. Any newly arrived PCBs are added to the new state
4. Currently running bursts of PCBs in the CPU and IO states are decremented -1
5. For round robin simulations, CPU processes are checked to see if their timeslice is expired and returned to the ready state
6. Any PCB in CPU or IO which has completed its current burst is moved to the wait or ready state respectively
7. Based on available CPU state slots, PCBs in the ready state are added to the CPU 
8. Based on available IO state slots, PCBs in the wait state are added to the IO 
9. Information for each PCB is displayed to the terminal as a rich table
10. The clock is incremented +1

The simulation runs as a  ==while== loop with the end condition as all states (lists) except Terminated are empty. Each PCB is an instance of a class kept in a dictionary and contains, as attributes, all of the collected data for the PCB as it was passed through the simulated system. 

#### Simulation Output
The following information is collected for each PCB regarding its progression through the simulated system:

  - Turn around time (total time in system)
  - Time in wait state
  - Time in ready state
  - CPU/IO ratio (gives a measure of the CPU vs IO intensity of the PCB)
  - CPU utilization (time PCB spent in CPU vs other states)

For each PCB batch, aggreagated information was calculated from the individual PCB data to include:

  - Average time in system for PCBs
  - Average wait time
  - Average ready time
  - CPU utilization (percent of time CPU was occupied by running PCBs)

Each of these data points were displayed both to the terminal as well as written to a .csv file named in accordance to the algorithm type, PCB batch type, CPU#, IO# and date.  The output files will be used to generate graphical representation of the simulations to give comparative feedback on algorithm efficiency under varying situations (i.e. CPU intensive, or CPU number).

### Required Packages
- rich Table
- rich Console
- rich Live
- csv
- argparse

### Scheduler Simulation Program Files ###
|                  Program                   |            Description             |        Author         |
| :----------------------------------------: | :--------------------------------: | :-------------------: |
|[sim_layout.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/sim_layout.py) |simulation program based on main with added output display tables|  Scales, Lopez  |
|[main.py]() | initial merged version of standalone programs | Lopez, Scales|
|[fcfsp.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/fcfsp.py)|stand alone file to run priority based FCFS simulation | Scales, Lopez|
|[fcfs.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/fcfs.py)| stand alone file to run FCFS simulation | Scales, Lopez |
| [rr.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/rr.py)    |     stand alone file to run round robin simulation     | Scales, Lopez |
| [generate_input.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/generate_input.py)   | used to generate PCBs as a datafile |    Griffin  |
|[SEven.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/SEven.dat)|  input data file |  Mitchell|
|[SCPUInt.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/SCPUInt.dat)| input data file  |  Mitchell|
|[SIOInt.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/SIOInt.dat)| input data file  |  Mitchell|
|[MEven.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/MEven.dat)| input data file  |  Mitchell|
|[MCPUInt.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/MCPUInt.dat)|  input data file |  Mitchell|
|[MIOInt.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/MIOInt.dat)|input data file   |  Mitchell|
|[LEven.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/LEven.dat)|  input data file |  Mitchell|
|[LCPUInt.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/LCPUInt.dat)|  input data file |  Mitchell|
|[LIOInt.dat](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/LIOInt.dat)| input data file  |  Mitchell|
|[outputM](https://github.com/jonscales/5143-opsys-102/tree/main/Assignments/P03/outputM)|Folder with simulation run data output .csv files|Lopez |

### Instructions

- Run [sim_layout.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/sim_layout.py) program with parameters from the list below. 
                                     
#### Commands List 
[sim_layout.py](https://github.com/jonscales/5143-opsys-102/blob/main/Assignments/P03/sim_layout.py) is run from the command line with these parameters : 

| Parameter |       Syntax       |       notes       |
| :-----: | :----------------------: | :---------------: |
|   PCB data filename   |   SEven.dat     |  required |
|  algorithm type  |    -a FCFS   |optional (default is FCFS)|
|   cpu number   |    -c 4     |optional (default 1)|
|   io number   |     -i 4     |optional (default 1)|
|  timeslice  |      -t 3      |   otional (default 5) only used for RR                |
|   simulation speed    |    -s .01   |         optional (default .01)          |
|   output filename    |       -o output.csv    |     optional (default = algorithmtype_inputtype_cpu#_IO#_timestamp.csv)              |


### References
- Dr. Giffin's code was a helpful starting point.
- Various authors made use of either ChatGPT or CoPilot for formatting, comments, or direction
